Le langage Java est un langage de programmation informatique orienté objet créé par James Gosling et Patrick Naughton, employés de Sun Microsystems, avec le soutien de Bill Joy (cofondateur de Sun Microsystems en 1982), présenté officiellement le 23 mai 1995 au SunWorld. La société Sun a été rachetée en 2009 par la société Oracle qui possède et maintient désormais Java.
Sommaire

    1 Aperçu
    2 Historique
        2.1 L'origine du langage
        2.2 Java rencontre l'internet
            2.2.1 Origine du nom Java
            2.2.2 Lancement public de Java
        2.3 Histoire récente
            2.3.1 Utilisation Web
                2.3.1.1 Côté client
                2.3.1.2 Côté serveur
            2.3.2 Utilisation sur le poste de travail
            2.3.3 Utilisation avec les mobiles
            2.3.4 Microsoft et autres systèmes
            2.3.5 Passage sous licence libre
            2.3.6 Acquisition par Oracle
        2.4 Historique des versions
    3 Philosophie
        3.1 Un langage orienté objet et familier
        3.2 Mécanisme du ramasse-miettes (Garbage Collector)
        3.3 Indépendance vis-à-vis de la plate-forme
        3.4 Exécution sécurisée de code distant
    4 Le langage
        4.1 Mots réservés, primitifs et littéraux
        4.2 Structures de contrôle
            4.2.1 Les collections d'objets
            4.2.2 Boucles
            4.2.3 Structures conditionnelles
            4.2.4 Traitement des exceptions
            4.2.5 Types génériques
            4.2.6 Encodage du code source
    5 JavaStyle
    6 Licence
    7 Frameworks et API
    8 Programmation
        8.1 Construction
    9 Notes et références
    10 Voir aussi
        10.1 Articles connexes
        10.2 Liens externes
        10.3 Bibliographie

Aperçu

La particularité principale de Java est que les logiciels écrits dans ce langage sont très facilement portables sur plusieurs systèmes d’exploitation tels que UNIX, Windows, Mac OS ou GNU/Linux, avec peu ou pas de modifications. C’est la plate-forme qui garantit la portabilité des applications développées en Java.

Le langage reprend en grande partie la syntaxe du langage C++, très utilisée par les informaticiens. Néanmoins, Java a été épuré des concepts les plus subtils du C++ et à la fois les plus déroutants, tels que les pointeurs et références, et l’héritage multiple remplacé par l’implémentation des interfaces. Les concepteurs ont privilégié l’approche orientée objet de sorte qu’en Java, tout est objet à l’exception des types primitifs (nombres entiers, nombres à virgule flottante, etc.)

Java permet de développer des applications client-serveur. Côté client, les applets sont à l’origine de la notoriété du langage. C’est surtout côté serveur que Java s’est imposé dans le milieu de l’entreprise grâce aux servlets, le pendant serveur des applets, et plus récemment les JSP (JavaServer Pages) qui peuvent se substituer à PHP, ASP et ASP.NET.

Java a donné naissance à un système d'exploitation (JavaOS), à des environnements de développement (eclipse/JDK), des machines virtuelles (MSJVM, JRE) applicatives multiplate-forme (JVM), une déclinaison pour les périphériques mobiles/embarqués (J2ME), une bibliothèque de conception d'interface graphique (AWT/Swing), des applications lourdes (Jude, Oracle SQL Worksheet, etc.), des technologies web (servlets, applets) et une déclinaison pour l'entreprise (J2EE). La portabilité du code Java est assurée par la machine virtuelle. JRE – la machine virtuelle qui effectue la traduction et l'exécution du bytecode en code natif – supporte plusieurs processus de compilation (à la volée/bytecode, natif). La portabilité est dépendante de la qualité de portage des JVM sur chaque OS.

Aujourd'hui, Java (sous la forme de JavaFX) trouve une nouvelle niche dans la création d'applications RIA (Rich Internet Application), des applications qui proposent des fonctionnalités, notamment des interfaces, plus évoluées à la fois sur Internet et sur les téléphones portables. Le langage JavaFX est un langage agile dérivé de Java, sous le contrôle d'Oracle, qui met à profit la portabilité de Java ainsi que les vastes bibliothèques déjà disponibles dans le langage Java.
Historique

Cet historique provient d’une traduction libre d’un article de la Wikipédia anglophone Java programming language.
N’hésitez pas à vérifier la qualité de la traduction pour être certain qu’il n’y ait pas de contresens.
L'origine du langage
Duke, la mascotte de Java

La plate-forme et le langage Java sont issus d’un projet de Sun Microsystems datant de 1990. L’ingénieur Patrick Naughton n’était pas satisfait par le langage C++ utilisé chez Sun, ses interfaces de programmation en langage C, ainsi que les outils associés. Alors qu’il envisageait une migration vers NeXT, on lui proposa de travailler sur une nouvelle technologie et c’est ainsi que le Projet Stealth (furtif) vit le jour.

Le Projet Stealth fut rapidement rebaptisé Green Project avec l’arrivée de James Gosling et de Mike Sheridan. Ensemble, aidés d’autres ingénieurs, ils commencèrent à travailler dans un bureau de la rue Sand Hill à Menlo Park en Californie. Ils essayèrent d’élaborer une technologie pour le développement d’applications d’une nouvelle génération, offrant à Sun la perspective d’opportunités uniques.

L’équipe envisageait initialement d’utiliser le langage C++, mais l’abandonna pour différentes raisons. Tout d’abord, ils développaient sur un système embarqué avec des ressources limitées et estimaient que l’utilisation du C++ demandait un investissement trop important et que cette complexité était une source d’erreur pour les développeurs. L'absence de ramasse-miettes impliquait que la gestion de la mémoire devait être programmée manuellement, un défi mais aussi une source d’erreur(s). L’équipe était aussi troublée par les lacunes du langage au niveau de la sécurité, de la programmation distribuée, du multi-threading. De plus, ils voulaient une plate-forme qui puisse être portée sur tout type d’appareils ou de plate-forme.

Bill Joy avait envisagé un nouveau langage combinant le meilleur du langage de programmation Mesa et du langage C. Dans un article appelé Plus loin (Further), il proposa à Sun que ses ingénieurs développent un environnement orienté objet basé sur le langage C++. À l’origine, Gosling envisageait de modifier et d’améliorer le langage C++, qu’il appelait C++ ++ --, mais l’idée fut bientôt abandonnée au profit du développement d’un nouveau langage de programmation qu’ils appelèrent Oak (chêne) en référence, selon la légende, à un arbre planté devant la fenêtre de leur bureau.

L’équipe travailla avec acharnement et, à l’été 1992, ils furent capables de faire une démonstration incluant le système d’exploitation Green, le langage Oak (1992), les bibliothèques et le matériel. Leur première réalisation, présentée le 3 septembre 1992, fut la construction d’un PDA appelé Star7 ayant une interface graphique et un agent intelligent appelé Duke pour prêter assistance à l’utilisateur. En novembre de la même année, le Green Project fut abandonné pour devenir FirstPerson, Inc, appartenant en totalité à Sun Microsystems et l’équipe fut relocalisée à Palo Alto. L’équipe FirstPerson était intéressée par la construction d’outils hautement interactifs et quand Time Warner publia un appel d’offres en faveur d’un décodeur multifonctions, FirstPerson changea d’objectif pour proposer une telle plate-forme. Cependant, l’industrie de la télévision par câble trouva qu’elle offrait trop de possibilités à l’utilisateur et FirstPerson perdit le marché au profit de Silicon Graphics. Incapable d’intéresser l’industrie audiovisuelle, la société fut réintégrée au sein de Sun.
Java rencontre l'internet

De juin à juillet 1994, après trois jours de remue-méninges avec John Gage, James Gosling, Joy, Naughton, Wayne Rosing et Eric Schmidt, l’équipe recentra la plate-forme sur le web. Ils pensaient qu’avec l’avènement du navigateur Mosaic, Internet était le lieu où allait se développer le même genre d’outil interactif que celui qu’ils avaient envisagé pour l’industrie du câble. Naughton développa comme prototype un petit navigateur web, WebRunner qui deviendra par la suite HotJava.

La même année le langage fut renommé Java après qu’on eut découvert que le nom Oak était déjà utilisé par un fabricant de carte vidéo.
Origine du nom Java

Le nom Java fut inventé dans un petit bar fréquenté par quelques membres de l’équipe. Il n’a pas été déterminé clairement si oui ou non le nom est un acronyme, bien que certains prétendent qu’il signifie James Gosling, Arthur Van Hoff et Andy Bechtolsheim ou tout simplement Just Another Vague Acronym (littéralement « juste un acronyme vague de plus »). La croyance selon laquelle Java doit son nom aux produits vendus dans le bar est le fait que le code sur 4 octets (également appelé nombre magique) des fichiers de classe est en hexadécimal 0xCAFEBABE.

Certaines personnes prétendent également que le nom de Java vient du fait que le programme était destiné à pouvoir tourner sur des systèmes embarqués, comme des cafetières (Java signifie café en argot américain).
Lancement public de Java

En octobre 1994, HotJava et la plate-forme Java furent présentés pour Sun Executives. Java 1.0a fut disponible en téléchargement en 1994 mais la première version publique du navigateur HotJava arriva le 23 mai 1995 à la conférence SunWorld.

L’annonce fut effectuée par John Gage, le directeur scientifique de Sun Microsystems. Son annonce fut accompagnée de l’annonce surprise de Marc Andressen, vice-président de l’exécutif de Netscape que Netscape allait inclure le support de Java dans ses navigateurs. Le 9 janvier 1996, le groupe Javasoft fut constitué par Sun Microsystems pour développer cette technologie2. Deux semaines plus tard la première version de Java était disponible.
Histoire récente

Oracle annonce début Octobre 2012 à la conférence JavaOne sa volonté de proposer des solutions Java pour le domaine des logiciels embarqués, pour processeurs moins puissants que ceux habituellement disponibles sur les PC. Oracle fédère autour d'elle tout un éco-système d'entreprises spécialistes de ces segments de marchés, comme l'éditeur IS2T ou encore STMicroelectronis qui propose du Java sur ses STM32 dont le coeur est un CortexM3/M4.
Utilisation Web
Côté client

Historiquement, la possibilité des navigateurs Web de lancer des applets Java était la seule solution pour afficher des applications clientes riches (RIA pour Rich Internet Application). Des technologies concurrentes ont émergé parmi lesquelles Macromedia Flash, le DHTML JavaScript, Silverlight basé sur XAML ou Xul.

Les applets sur le poste Client peuvent communiquer avec des servlets sur le Serveur, tout comme Javascript peut communiquer avec le Serveur au moyen d’AJAX. Flex utilise la technologie Flash par le biais du Adobe Flash Player.

À une époque où Javascript souffrait de problèmes de compatibilité inter-navigateur, les applets Java avaient l'avantage de la portabilité car le portage d'interfaces complexes était difficile à assurer pour tous les navigateurs du marché.

Mais les progrès faits dans les technologies concurrentes à Java ont amené la plupart des développeurs à se détourner des applets Java et des problèmes inhérents à cette technologie (incompatibilités entre les JVM, mauvaises performances, pauvreté des bibliothèques graphiques, complexité) et de la retombée de la « mode » Java. Enfin, les navigateurs modernes n'incluent plus systématiquement l'environnement Java à cause de sa taille importante et le taux de machines capables d'afficher des applets n'était plus que de 70 % en 2010, bien plus faible que pour Flash par exemple3. En 2010, la quasi-totalité des applications clients riches utilisent des technologies alternatives ; Flash pour l'essentiel mais aussi GWT.

Enfin, la perspective de l'arrivée prochaine de HTML5, destiné à embarquer de nombreuses fonctionnalités RIA et multimédia, rend également les applets caduques.
Côté serveur

Côté serveur, on retrouve des classes Java qui permettent de définir des objets (classes POJO) et d'autres classes qui permettent de définir des actions sur ces objets (classes métiers). On effectue ici un travail sur les données en les modélisant sous formes d'objets. Ces objets peuvent être modifiés par des méthodes issues de classes spécialement conçues pour effectuer des opérations. Ainsi on pourra trouver par exemple une classe pour définir une pomme en tant qu'objet (taille, poids, calibre) et une autre classe pour définir des opérations sur une pomme (acheter, vendre, manger). Avec les serveurs d’applications, on utilise des EJB pour encapsuler les classes définies précédemment. Ces éléments sont utilisés dans des architectures J2EE pour des applications multicouches. L'avantage qu'on tire de ce travail est de pouvoir cacher au client l'implémentation du code côté serveur.
Utilisation sur le poste de travail

L’utilisation native du langage Java pour des applications sur un poste de travail restait jusqu'à présent relativement rare à cause de leur manque de rapidité. Cependant, avec l’accroissement rapide de la puissance des ordinateurs, les améliorations au cours de la dernière décennie de la machine virtuelle Java et de la qualité des compilateurs, plusieurs technologies ont gagné du terrain comme par exemple Netbeans et l’environnement Eclipse, les technologies de fichiers partagés Limewire et Azureus. Java est aussi utilisé dans le programme de mathématiques Matlab, au niveau de l’interface homme machine et pour le calcul formel. Les applications Swing apparaissent également comme une alternative à la technologie .NET.
Utilisation avec les mobiles

Java, et le langage qui en dérive : JavaFX, essaye d'occuper une niche pressentie pour devenir un marché d'avenir important : les plateformes mobiles (PDA, tablettes, téléphones). Cependant, là encore, la concurrence est rude. Microsoft Silverlight, et la convergence de Flash et de JavaScript/Ecmascript en ActionScript, sont également bien positionnées dans ce nouveau domaine. Java, notamment via Eclipse et NetBeans, offre déjà des environnements de développement intégrés pour mobile. Java est le principal langage utilisé pour développer des applications pour le système d'exploitation libre pour Mobile de Google : Android.
Microsoft et autres systèmes

    Microsoft a fourni un environnement de travail de type Java, dénommé J++, avec ses systèmes d’exploitation avant la sortie de Windows XP en 2001. Suite à une décision de justice[réf. nécessaire], et au vu du non-respect des spécifications de ce langage, Microsoft a dû abandonner celui-ci et créer un nouveau langage, de nom C# (cf. chapitre « Indépendance vis-à-vis de la plate-forme » plus bas)
    Beaucoup de fabricants d’ordinateurs continuent d’inclure un environnement JRE sur leurs systèmes Windows.
    Java apparaît également comme un standard au niveau du MacOS X d’Apple aussi bien que pour les distributions Linux. De nos jours, la plupart des utilisateurs peuvent lancer des applications Java sans aucun problème.
    Toutefois, sur ordinateur Apple, la distribution de Java est assurée directement par Apple, et non par Oracle4. Cette politique entraîne des retards et des restrictions de version.

    Ainsi J2SE 1.4 ne fut pas disponible avant Mac OS X v10.2 (nom de code Jaguar), J2SE 5.0 à partir de Mac OS X v10.4 (Tiger), Java SE 6 fonctionne uniquement sous Mac OS X v10.5 (Leopard) équipé de processeur Intel5, et Java 7 exige un ordinateur Mac Intel exécutant la version Mac OS X v10.7.3 (Lion).

Passage sous licence libre

Le 13 novembre 2006, Sun annonce le passage de Java, c’est-à-dire le JDK (JRE et outils de développement) et les environnements Java EE (déjà sous licence CDDL) et Java ME sous licence GPL. En mai 2007, Sun publie effectivement OpenJDK sous licence libre. Cependant OpenJDK dépend encore de fragments de code non libre que Sun ne détient pas. C'est pourquoi la société Redhat lance en juin 2007 le projet IcedTea qui vise à remplacer les fragments de code non libre et ainsi rendre OpenJDK utilisable sans aucun logiciel propriétaire. En juin 2008, le projet IcedTea a passé les tests rigoureux de compatibilité Java (TCK)6. On peut donc dire que Java devient un logiciel libre.
Acquisition par Oracle

La société Oracle a acquis en 2009 l'entreprise Sun Microsystems. On peut désormais voir apparaître le logo Oracle dans les documentations de l'api Java.

Le 12 avril 2010, James Gosling, le créateur du langage de programmation Java démissionne d’Oracle pour des motifs qu’il ne souhaite pas divulguer. Il était devenu le directeur technologique de la division logicielle client pour Oracle.
Historique des versions

Le langage Java a connu plusieurs évolutions depuis le JDK 1.0 (Java Development Kit) avec l’ajout de nombreuses classes et packages à la bibliothèque standard. Depuis le J2SE1.4, l’évolution de Java est dirigée par le JCP (Java Community Process) qui utilise les JSR (Java Specifications Requests) pour proposer des ajouts et des changements sur la plate-forme Java. Le langage est spécifié par le JLS (Java Language Specification). Les modifications du JLS sont gérées sous le code JSR 9017.

    JDK 1.0 (23 janvier 1996 - 211 classes et interfaces) — Version initiale8.

    JDK 1.1 (19 février 1997 - 477 classes et interfaces) — De nombreux ajouts9 avec notamment :
        une refonte complète du modèle événementiel AWT.
        Les classes internes sont ajoutées au langage.
        JavaBeans.
        JDBC.
        Java Remote Invocation (RMI).

    J2SE 1.2 (9 décembre 1998 - 1 524 classes et interfaces) — Nom de code Playground. Cette version et les suivantes jusque J2SE 5.0 sont rebaptisées Java 2 et la version nommée J2SE (Java 2 Platform, Standard Edition) remplace JDK pour distinguer la plate-forme de base de la version J2EE (Java 2 Platform, Enterprise Edition) et de la version J2ME (Java 2 Platform, Micro Edition). Plusieurs ajouts10 dont :
        le mot-clé strictfp (strict floating-point : virgule flottante stricte)
        la réflexion
        l’API graphique Swing est intégrée.
        Pour la première fois, la machine virtuelle Java de Sun inclut un compilateur « Juste à temps » (Just in Time).
        Java Plug-in
        Java IDL, une implémentation de IDL pour l’interopérabilité avec CORBA.
        le framework Collections.

    J2SE 1.3 (8 mai 2000 - 1 840 classes et interfaces) — Nom de code Kestrel. Changements principaux11 :
        HotSpot JVM inclus (La machine virtuelle HotSpot sortit en avril 1999 pour la machine virtuelle du J2SE 1.2)
        Changement pour les RMI pour être basé sur CORBA.
        JavaSound
        JNDI (Java Naming and Directory Interface) inclus de base (disponible auparavant comme extension)
        JPDA (Java Platform Debugger Architecture)

    J2SE 1.4 (6 février 2002 - 2 723 classes et interfaces) — Nom de code Merlin. Ce fut la première révision de la plate-forme sous JCP (Java Community Process)12. Les principaux changements13 sont :
        le mot-clé assert (Spécifié dans JSR 41.)
        les expressions rationnelles modélisées en s’inspirant du langage Perl.
        Le chaînage d’exception permet à une exception d’encapsuler l’exception de base niveau d’origine. (Spécifié dans (en) JSR 51.)
        API de journalisation (Spécifiée dans (en) JSR 47.)
        l’API Image I/O pour lire et écrire des images dans des formats comme JPEG et PNG.
        intégration d’un parser XML et du moteur XSLT nommé JAXP (Spécifié dans (en) JSR 5 et (en) JSR 63.)
        intégration des extensions de sécurité JCE (Java Cryptography Extension), JSSE et JAAS.
        Java Web Start (introduit pour la première fois en mars 2001 pour J2SE 1.3 - Spécifié dans (en) JSR 56.)

    J2SE 5.0 (30 septembre 2004 - 3 270 classes et interfaces) — Nom de code Tiger. (initialement numérotée 1.5, qui est toujours utilisé comme numéro de version interne14). Développé par (en) JSR 176, Tiger ajoute un nombre significatif de nouveautés15 au langage :
        Programmation générique — (Spécifié par (en) JSR 14.)
        Metadata — également appelées annotations, permet au langage de construire des classes et des méthodes étiquetées avec des données additionnelles qui peuvent être utilisées en tant que méta-données (Spécifiée dans (en) JSR 175.)
        Autoboxing/unboxing — conversion automatique entre des types primitifs (comme le type int) et le Wrapper de classe correspondant (comme la classe Integer) (Spécifié dans (en) JSR 201).
        Énumérations — le mot-clé enum permet de créer une liste ordonnée de valeurs en gardant la sûreté du typage. Auparavant, ceci pouvait seulement être réalisé par des entiers constants (Spécifié dans JSR 201).
        Varargs — la syntaxe Object... utilisée dans une déclaration de méthode permet de spécifier un nombre variable d’arguments pour cette méthode. C’est un fonctionnement équivalent à la fonction « printf » en C.
        Imports statiques — Cette fonctionnalité permet d’utiliser les constantes d’une classe sans spécifier le nom de cette classe et sans passer par « l’anti-pattern Constant Interface » (c’est l’expression utilisée sur le site de Sun).
        Extension du for pour les boucles — la syntaxe du for est étendue avec une syntaxe spéciale pour itérer sur n’importe quel objet itérable comme un tableau, ou une collection en utilisant la syntaxe :

        void displayWidgets (Iterable<Widget> widgets) {
            for (Widget w : widgets) {
                w.display();
            }
        }

        cet exemple parcourt le contenu de l’objet widgets de la classe Iterable et contenant uniquement des références vers des objets de la classe Widget, assignant chacun de ces éléments à la variable w et ensuite appelle la méthode display() sur l’élément w (spécifié dans JSR 201).

    Java SE 6 (11 décembre 2006 - 3 777 classes et interfaces) — Nom de code Mustang16. Une version bêta est sortie le 15 février 2006, une autre bêta en juin 2006, une version « release candidate » en novembre 2006, et la version finale le 12 décembre 2006. Avec cette version, Sun remplace le nom J2SE par Java SE et supprime le .0 au numéro de version17.

    Java SE 7 (7 juillet 2011) — Nom de code Dolphin. Il s’agira de la première version sous la licence GPL.

En plus des changements au niveau du langage, des changements plus importants ont eu lieu au fil des années qui ont conduit des quelques centaines de classes dans le JDK 1.0 à plus de 3 000 dans J2SE 5.0. Des API entières, comme Swing ou Java2D ont été ajoutées et beaucoup de méthodes de l’original JDK 1.0 ont été déclarées deprecated (c’est-à-dire déconseillées, elles pourraient être supprimées dans une version ultérieure de Java).

    Java SE 8 Une des nouveautés majeures de cette version sera l’ajout des closures (en cours de spécifications). La modularisation de la JVM avec le projet Jigsaw, initialement prévue pour cette version, est elle reportée à la version 918.

Philosophie

Lors de la création du langage Java, il avait été décidé que ce langage devait répondre à 5 objectifs19 :

    simple, orienté objet et familier ;
    robuste et sûr ;
    indépendant de la machine employée pour l'exécution ;
    très performant ;
    interprété, multi-tâches et dynamique.

Un langage orienté objet et familier
Article connexe : Programmation orientée objet.

La première caractéristique, le caractère orienté objet (« OO ») et familier, fait référence à une méthode de programmation et de conception du langage et le fait qu'un programme écrit en Java ressemble assez fort à un programme écrit en C++.

Bien qu’il existe plusieurs interprétations de l’expression orienté objet, une idée phare dans ce type de développement est que les différents types de données doivent être directement associés avec les différentes opérations qu’on peut effectuer sur ces données. En conséquence, les données (appelées Propriétés) et le code les manipulant (appelé Méthodes) sont combinés dans une même entité appelée Classe d'objet. Le code devient logiquement découpé en petites entités cohérentes et devient ainsi plus simple à maintenir et plus facilement réutilisable, étant intrinsèquement modulaire.

D’autres mécanismes tels l’héritage permettent d’exploiter toutes les caractéristiques d’une Classe précédemment écrite dans ses propres programmes sans même avoir à en connaître le fonctionnement interne, on n’en voit que l’interface (l'interface décrit les propriétés et les méthodes sans fournir le code associé). Java interdit la notion d'héritage depuis plusieurs classes parent sauf si elles sont des interfaces.

Dans la version 1.5 du langage ont été rajoutés les génériques, un mécanisme de polymorphisme semblable (mais différent) aux templates du langage C++ ou aux foncteurs d’Objective Caml. Les génériques permettent d’exprimer d’une façon plus simple et plus sûre les propriétés d’objets comme des conteneurs (listes, arbres…) : le type liste est alors considéré génériquement par rapport au type d’objet contenu dans la liste.
Mécanisme du ramasse-miettes (Garbage Collector)
Article connexe : Ramasse-miettes en informatique.

Cet élément contribue à la robustesse et à la performance des programmes, le ramasse-miettes est appelé régulièrement et automatiquement pendant l'exécution du programme. Sur les systèmes multi-processeurs et/ou multi-cœurs celui-ci emploie même des threads multiples à faible priorité afin de perturber le moins possible l'exécution de programme20. En outre, le programmeur peut au besoin suggérer de lancer le ramasse-miettes à l’aide de la méthode System.gc().

Un grief récurrent à l’encontre de langages comme C++ est la lourde tâche d’avoir à programmer manuellement la gestion de la mémoire. En C++, la mémoire allouée par le programme pour créer un objet est désallouée lors de la destruction de celui-ci (le plus souvent par un appel explicite à l'opérateur delete). Si le programmeur oublie de coder la désallocation, ceci aboutit à une « fuite mémoire », et le programme en consomme de plus en plus. Pire encore, si par erreur un programme demande plusieurs fois une désallocation, ou emploie une zone de mémoire après avoir demandé sa désallocation, celui-ci deviendra très probablement instable et se plantera.

En Java, une grande partie de ces problèmes est évitée grâce au ramasse-miettes. L'espace mémoire nécessaire à chaque objet créé est alloué dans un tas de mémoire en anglais : memory heap réservé à cet usage. Le programme peut ensuite accéder à chaque objet grâce à sa référence dans le tas. Quand il n'existe plus aucune référence permettant d'atteindre un objet, le ramasse-miettes le détruit automatiquement — puisqu'il est devenu inaccessible — libérant la mémoire et prévenant ainsi toute fuite de mémoire.

Le ramasse-miettes emploie un algorithme de marquage puis libération en anglais : mark and sweep20 qui permet de gérer les cas complexes d'objets se référençant mutuellement ou de boucles de références (cas d'une liste à chaînage double par exemple). En pratique il subsiste des cas d'erreur de programmation où le ramasse-miettes considèrera qu'un objet est encore utile alors que le programme n'y accèdera plus, mais dans l’ensemble, le ramasse-miettes rend plus simple et plus sûre la destruction d’objets en Java (en supprimant la nécessité de placer au bon endroit du code l'appel à l'opérateur delete).
Indépendance vis-à-vis de la plate-forme
Articles connexes : Bytecode Java et Compilation à la volée.

L’indépendance vis-à-vis de la plate-forme signifie que les programmes écrits en Java fonctionnent de manière parfaitement similaire sur différentes architectures matérielles. On peut effectuer le développement sur une architecture donnée et faire tourner l’application sur toutes les autres.

Ce résultat est obtenu par les compilateurs Java qui compilent le code source « à moitié » afin d’obtenir un bytecode (plus précisément le bytecode Java, un langage de type assembleur, proche de la machine virtuelle et spécifique à la plate-forme Java). Le code est ensuite interprété sur une machine virtuelle Java (JVM en anglais), un programme écrit spécifiquement pour la machine cible qui interprète le bytecode Java et fait exécuter par la machine les instructions traduites en code natif. De plus, des bibliothèques standard sont fournies pour pouvoir accéder à certains éléments de la machine hôte (le graphisme, le multithreading, la programmation réseau…) exactement de la même manière sur toutes les architectures.

Notons que même s’il y a explicitement une première phase de compilation, le bytecode Java est soit interprété, soit converti à la volée en code natif par un compilateur à la volée (just in time, JIT).

Il existe également des compilateurs Java qui compilent directement le Java en code objet natif pour la machine cible, comme par exemple GCJ, supprimant la phase intermédiaire du bytecode mais le code final produit par ces compilateurs ne peut alors être exécuté que sur une seule architecture.

La licence de Sun pour Java insiste sur le fait que toutes les implémentations doivent être compatibles. Cela a abouti à la plainte en justice contre Microsoft après que Sun a constaté que l’implémentation de Microsoft ne supportait pas les interfaces RMI et JNI et comportait des éléments spécifiques à certaines plates-formes par rapport à la plate-forme initiale de Sun. Sun obtint des dommages et intérêt (20 millions de dollars) et l’acte de justice renforça encore les termes de la licence de Sun. En réponse, Microsoft arrêta le support de Java sur ses plates-formes et, sur les versions récentes de Windows, Internet Explorer ne supporte pas les applets Java sans ajouter de plug-in. Cependant, Sun met à disposition gratuitement des environnements d’exécution de Java pour les différentes plates-formes Microsoft.

Les premières implémentations du langage utilisaient une machine virtuelle interprétée pour obtenir la portabilité. Ces implémentations produisaient des programmes qui s’exécutaient plus lentement que ceux écrits en C ou en C++, si bien que le langage souffrit d’une réputation de faibles performances. Des implémentations plus récentes de la machine virtuelle Java (JVM) produisent des programmes beaucoup plus rapides qu’auparavant, en utilisant différentes techniques.

La première technique est de compiler directement en code natif comme un compilateur traditionnel, supprimant complètement la phase de bytecode. On obtient ainsi de bonnes performances mais aux dépens de la portabilité. Une autre technique appelée compilation juste-à-temps (just in time, JIT) traduit le byte code en code natif durant la phase de lancement du programme. Certaines machines virtuelles plus sophistiquées utilisent une recompilation dynamique durant laquelle la machine virtuelle analyse le comportement du programme et en recompile sélectivement certaines parties. La recompilation dynamique permet d’obtenir de meilleurs résultats que la compilation statique car les compilateurs dynamiques peuvent optimiser en fonction de leur connaissance de l’environnement cible et des classes qui sont utilisées. La compilation JIT et la recompilation dynamique permettent à Java de tirer profit de la rapidité du code natif sans perdre la portabilité.

La portabilité est techniquement un objectif difficile à atteindre et le succès de Java en ce domaine est mitigé. Quoiqu’il soit effectivement possible d’écrire des programmes pour la plate-forme Java qui fonctionnent correctement sur beaucoup de machines cibles, le nombre important de plates-formes avec de petites erreurs et des incohérences a abouti à un détournement du slogan de Sun « Write once, run anywhere » (« Écrire une fois, exécuter partout ») en « Write once, debug everywhere » (« Écrire une fois, déboguer partout ») !

L’indépendance de Java vis-à-vis de la plate-forme est cependant un succès avec les applications côté serveur comme les services web, les servlets et le Java Beans aussi bien que les systèmes embarqués sur OSGi, utilisant l’environnement Embedded Java.


Exécution sécurisée de code distant

La plate-forme Java fut l’un des premiers systèmes à offrir le support de l’exécution du code à partir de sources distantes. Une applet peut fonctionner dans le navigateur web d’un utilisateur, exécutant du code téléchargé d’un serveur HTTP. Le code d’une applet fonctionne dans un espace très restrictif, ce qui protège l’utilisateur des codes erronés ou mal intentionnés. Cet espace est délimité par un objet appelé gestionnaire de sécurité. Un tel objet existe aussi pour du code local, mais il est alors par défaut inactif.

Le gestionnaire de sécurité (la classe SecurityManager) permet de définir un certain nombre d’autorisations d’utilisation des ressources du système local (système de fichiers, réseau, propriétés système, …). Une autorisation définit

    un code accesseur (typiquement, une applet - éventuellement signée - envoyée depuis un serveur web) ;
    une ressource locale concernée (par exemple un répertoire) ;
    un ensemble de droits (par exemple lire/écrire).

Les éditeurs d’applet peuvent demander un certificat pour leur permettre de signer numériquement une applet comme sûre, leur donnant ainsi potentiellement (moyennant l’autorisation adéquate) la permission de sortir de l’espace restrictif et d’accéder aux ressources du système local.
Le langage

Voici un exemple d’un programme Hello world typique écrit en Java :

 class HelloWorld {
     public static void main(String[] args) {
         System.out.println("Hello world!");
     }
 }

Le fichier source porte presque toujours le nom de la classe avec l'extension ".java" (ici "HelloWorld.java", ce serait même obligatoire si la classe avait l'attribut public dans sa déclaration — la rendant alors accessible à tout autre programme). On peut compiler puis exécuter cet exemple avec les commandes suivantes (sous Linux) :

javac HelloWorld.java
export CLASSPATH=.
java HelloWorld

La ligne « export CLASSPATH=. » sert à indiquer à Java qu’il doit également chercher les programmes class dans le répertoire courant. Ce chemin peut également être spécifié au lancement du programme par l’option -classpath (ou -cp en abrégé) :

java -cp. HelloWorld

Mots réservés, primitifs et littéraux

abstract       else         instanceof   static           try        boolean   false
assert (1.4)   enum (5.0)   interface    strictfp (1.2)   volatile   byte      true
break          extends      native       super            while      char
case           final        new          switch                      double
catch          finally      package      synchronized                float
class          for          private      this                        int
const (*)      goto (*)     protected    throw                       long
continue       if           public       throws                      short
default        implements   return       transient                   void      null
do             import

Notes :

    (*) ces mots clefs sont réservés mais n'ont pas de signification pour le compilateur (il est juste interdit d'employer ce nom pour une variable par exemple) ;
    (1.2), (1.4) et (5.0) ces mots clefs ont été ajoutés avec la version indiquée du langage.

(source)
Structures de contrôle
Les collections d'objets

Il est souvent nécessaire de stocker de nombreuses données dans des collections : liste d’achats, notes des élèves, etc. Les collections peuvent être consultées, modifiées, on peut les trier, les recopier, les supprimer etc. Elles peuvent avoir une taille fixe ou variable.
Collections de taille fixe :

    Les tableaux : Pour initialiser un tableau d’entiers de 10 cases on écrit : int[] tab = new int[10]; Les indices du tableau vont dans ce cas de 0 à 9. Plus généralement, les indices d'un tableau de taille n vont de 0 à n-1. Un des plus grands avantages des tableaux est l’accès en temps constant O(1), à chaque case du tableau. Pour accéder ou modifier le ie élément du tableau, pour 0≤ i <n, on écrit tab[i]=2; pour attribuer la valeur 2 à une case du tableau. La propriété length (ex : tab.length) fournit le nombre d'éléments du tableau. Si on essaie de modifier un élément qui n’existe pas, par exemple tab [10] = 4; on va obtenir le message d’erreur suivant : IndexOutOfBoundsException car notre tableau tab ne contient que 10 cases (numérotées de 0 à 9 inclus). Un tableau une fois initialisé ne peut plus être redimensionné.

Collections de taille variable :

    ArrayList : pour initialiser une ArrayList il faut importer la classe java.util.ArrayList ; et écrire liste = new ArrayList(); depuis jdk 1.5 on a la possibilité d’indiquer le type des éléments contenus dans une ArrayList : entiers, string, etc.

            Cette collection est vide après l’appel du constructeur ;
            On peut ajouter autant d’éléments que l’on veut.

    Pour ajouter un élément on écrit liste.add(Objet);
    Pour accéder à un élément de l’ArrayList : liste.get(index);
    Pour connaître le nombre d’éléments que contient une liste : liste.size();
    Pour supprimer un élément : liste.remove(index); les éléments qui suivent l’élément supprimé seront décalés à gauche.

Boucles

Bien qu’elles aient toutes un rôle similaire, chaque boucle est pourtant adaptée à une situation :

    Structure tant que (adaptée pour effectuer des opérations tant qu’une condition est remplie) :

 while (<expression booléenne>) {
        instruction(s)
 }

    Structure faire … tant que (comme la structure tant que mais la première itération est exécutée quelle que soit la condition, pour les autres itérations la condition doit être remplie) :

 do {
    instruction(s)
 }
 while (<expression booléenne>);

    Structure pour (adaptée lorsqu'une collection doit être parcourue en totalité pour traitement) :

 for (<initialisation> ; <condition de poursuite> ; <expression d’incrémentation>) {
    instruction(s)
 }

    Structure pour chaque (simplification du for en for each, dans laquelle l'expression doit être un tableau ou une collection) :

 for (type variable : <expression>) 
 {
    instruction(s)
 }

    Structure pour (Java 1.5) :

 for (<Objet récupérant l’occurrence suivante de la collection> : <collection d’objets>){
    instruction(s)
 }

Structures conditionnelles

Structure si : condition simple

 if (<expression booléenne>) {
    instruction(s)
 }

Structure si … sinon : condition avec alternative unique

 if (<expression booléenne>) {
     instruction(s)
 }
 else {
     instruction(s)
 }

Structure si … ou si … ou si … : condition avec alternatives multiples

 if (<expression booléenne>) {
     instruction(s)
 }
 else if (<expression booléenne>) {
     instruction(s)
 }
 else if (<expression booléenne>) {
     instruction(s)
 }
 else {
     instruction(s)
 }

Structure atteindre … cas x … cas y …" : embranchement vers un bloc d’instructions énuméré

 switch (<expression de type numérique>) {
    case <constante de type numérique>:
         instruction(s)
         break;
    case <constante de type numérique>:
        instruction(s)
        break;
    [...]
    default:
         instruction(s)
         break;
 }

Remarques : vous pouvez également utiliser la structure de contrôle switch sur une énumération ; par ailleurs le switch ne fonctionne pas sur toutes les constantes de type numérique mais seulement sur les entiers. Switch fonctionne également avec des variables de type char.

La commande break sort immédiatement la boucle en cours (for, while, do), et permet de sortir d’une clause contenue dans un switch. Si le break est omis, l'exécution du switch se poursuit de case en case.

Une expression continue termine l’itération en cours et continue à la prochaine. Elle s’écrit comme suit : continue, mais son usage est à proscrire puisqu'elle tend à favoriser un type de programmation non structurée (programmation spaghetti).

L’énoncé return termine une méthode.

Avec return uneValeur, uneValeur sera renvoyée à la méthode appelante.

Opérateur ternaire ? : : Instruction conditionnelle pouvant être employée comme une expression

 <expression booléenne> ? <valeur si vrai> : <valeur si faux>

Traitement des exceptions

 try {
       instruction(s)
 }
 catch (<type exception> <variable>) {
       instruction(s)
 } 
 [...]
 finally {
       instruction(s)
 }

Le bloc de code finally sera exécuté quel que soit le résultat lorsque le programme sortira du bloc try-catch.

Voici un exemple de capture d’une exception :

 
 FileOutputStream fos = null; 
 
 try {
      //Chacune de ces deux instructions peut générer une exception
      // création d'un flux pour écrire dans un fichier
      fos = new FileOutputStream(...);
      // écriture de données dans ce flux
      fos.write(...);
 }
 catch (IOException e) {
      //Gestion de l'erreur de création ou d'écriture dans le flux
      e.printStackTrace();
 }
 finally{
     //Cette section de code est toujours exécutée, qu’il y ait une exception ou pas
     // fermeture du flux s'il a été ouvert
     if(fos != null) fos.close();
 }

Cet exemple permet d’illustrer le mécanisme des exceptions en Java. Dans le cas d’une erreur d’entrée/sortie dans le bloc try, l’exécution reprend dans le bloc catch correspondant à cette situation (exception de type IOException). Dans ce bloc catch, la variable e référence l’exception qui s’est produite. Ici, nous invoquons la méthode printStackTrace() qui affiche dans la console des informations sur l’exception qui s’est produite : nom, motif, état de la pile d’appels au moment de la levée de l’exception et, éventuellement, numéro de ligne auquel l’erreur s’est produite. Le bloc finally est ensuite exécuté (ici pour refermer les ressources utilisées). Il ne s’agit ici que d’un exemple, l’action à mettre en œuvre lorsqu’une exception survient dépend du fonctionnement général de l’application et de la nature de l’exception.
Types génériques

Un type générique est autrement appelé un Template, il prend un ou plusieurs autres types en arguments. Le type passé en paramètre est déterminé lors de l'instanciation. Cela permet notamment dans le cadre des ArrayList d'éviter les transtypages

 public class ArrayList<E> {
    ArrayList<String> al = new ArrayList<String>();
 }

Ces types génériques ne sont utilisés qu'à la compilation, et non directement dans le bytecode.

Différence avec le C++ : les templates en C++ dupliquent une classe pour chaque type. Java, au contraire, agit au moment de la compilation comme si on avait dupliqué les classes de ces types intrinsèques mais ne traite en réalité qu'avec une seule classe.
Encodage du code source

Les spécifications du langage Java précisent qu’il est formé de caractères au format UTF-16, ce qui permet l’utilisation dans le code source de tous les caractères existant dans le monde :

 public class hello_world {
    private String text = "hello world";
 }

Pour assurer la portabilité entre plates-formes, les noms de classes devraient néanmoins être formés uniquement de caractères ASCII.
JavaStyle

Les JavaStyle sont des conventions de programmation en langage Java définies par Sun. Le respect de conventions strictes assure une homogénéité dans le code source d’une application développée par toute une équipe et favorise la diffusion du code source auprès d’une communauté partageant les mêmes conventions de codage.

Cf. Les conventions de nommage édictées par Sun[PDF]
Licence

Le 11 novembre 2006, le code source du compilateur javac et de la machine virtuelle HotSpot ont été publiés en Open Source sous la Licence publique générale GNU21.

Le 13 novembre 2006, Sun Microsystems annonce que tout le code source de Java sera publié en Open Source sous la Licence publique générale GNU d’ici mars 2007 sous le nom de projet OpenJDK22.
Frameworks et API

Sun fournit un grand nombre de frameworks et d’API afin de permettre l’utilisation de Java pour des usages très diversifiés. On distingue essentiellement 4 grands frameworks :

    Java SE (anciennement J2SE) : Ce framework est destiné aux applications pour poste de travail.
    Java EE (anciennement J2EE)  : Ce framework est spécialisé dans les applications serveurs. Il contient pour ce faire un grand nombre d’API et d’extensions.
    Java ME (anciennement J2ME)  : Ce framework est spécialisé dans les applications mobiles.
    Java FX (à ne pas confondre avec JavaFX) : Ce framework est spécialisé dans les applications liées aux cartes à puces et autres SmartCards. Il recouvre notamment l'ancien Java Card

La persistance est basée sur les standards :

    JDBC (Java DataBase Connectivity)
    JDO (Java Data Objects)
    EJB (Enterprise Java Beans)

On trouve toutefois de nombreuses autres technologies, API et extensions optionnelles pour Java :

    JavaMedia : Framework multimédia, contenant notamment les API Java2D, Java3D, JavaSound, Java advanced Imaging
    Java Telephony
    Java TV
    JXTA : Système de peer-to-peer reposant sur Java
    Jini
    JAIN
    JDMK
    JavaSpeech
    JMI
    JavaSpaces

Programmation

La programmation peut se faire pour des exemples simples avec le compilateur javac, mais pour avoir plus de confort il est préférable d’utiliser un environnement de développement intégré ou IDE, certains sont gratuits.

    Environnements existants
        BlueJ
        CodeWarrior
        Eclipse
        Idea
        JBuilder
        JCreator
        jDeveloper
        NetBeans
        Xcode

Construction

Un programme Java peut être produit avec des outils qui automatisent le processus de construction (c'est-à-dire l'automatisation de certaines tâches faisant appel à un nombre potentiellement grand de dépendances comme l'utilisation de bibliothèques, la compilation, la génération d'archives, de documentation, le déploiement, etc.). Les plus utilisés sont :

    Apache Ant (génération portable, décrite en XML) ;
    Apache Maven (génération portable, décrite en XML) ;
    Gradle (génération portable, en utilisant le langage Groovy) ;
    SCons (génération portable de Java/C/C++). Exemple :

      Java(target = 'classes', source = 'src')
      Jar(target = 'test.jar', source = 'classes')

Résultats :

     % scons -Q
     javac -d classes -sourcepath src src/Exemple1.java src/Exemple2.java src/Exemple3.java
     jar cf test.jar classes

Notes et références

    ↑ In Java 5.0, several features (the enhanced for loop, autoboxing, varargs, annotations and enums) were introduced, after proving themselves useful in the similar (and competing) language C#. [1] [archive][2] [archive][3] [archive]
    ↑ (en) Sun Microsystems Announces Formation Of Javasoft [archive]
    ↑ http://riastats.com/ [archive]
    ↑ Apple Java 6 pour Mac OS X [archive] FAQ www.java.com/fr/download
    ↑ Technical Notes TN2110 [archive] developer.apple.com
    ↑ http://blog.softwhere.org/archives/196 [archive]
    ↑ (en) The Java Community Process(SM) Program - JSRs : Java Specification Requests - detail JSR# 901 [archive]
    ↑ (en) communiqué de presse [archive]
    ↑ (en) communiqué de presse [archive]
    ↑ (en) communiqué de presse [archive]
    ↑ (en) communiqué de presse [archive] - (en) liste complète des changements [archive]
    ↑ (en) JSR 59 [archive]
    ↑ (en) communiqué de presse [archive] - (en) liste complète des changements [archive]
    ↑ (en) Version 1.5.0 or 5.0? [archive]
    ↑ (en) communiqué de presse [archive]
    ↑ (en) JSR 270 [archive]
    ↑ (en) Java Naming [archive]
    ↑ [4] [archive]
    ↑ (en) Design Goals of the Java Programming Language [archive]
    ↑ a et b Voir par exemple les détails du fonctionnement et la description des options -XX:+UseParallelGC et -XX:+UseConcMarkSweepGC de la JRE de Sun (en) Java SE Virtual Machine Garbage Collection Tuning [archive]
    ↑ (en) "Q: What components of the JDK software are you open sourcing today? A: We’re open sourcing the Java programming language compiler ("javac"), and the Java HotSpot virtual machine."Free and Open Source Java FAQ [archive]; the source is being released via the OpenJDK [archive] project.
    ↑ Sun Open Sources Java Platform [archive], Sun Microsystems, 13 novembre 2006. Consulté le 13 novembre 2006

Voir aussi

Sur les autres projets Wikimedia :

    Java, sur le Wiktionnaire
    Java (langage), sur Wikiversity
    Java (langage), sur Wikibooks

Articles connexes

    Plate-forme Java
    Machine virtuelle Java
    Bytecode Java
    Java et logiciel libre
    Servlet
    Navigateur HotJava
    GNU Compiler Collection (inclut un compilateur de code Java vers code natif, GCJ)
    .properties, manière de stocker les variables de configuration
    Processing
    Jam (langage)

Liens externes

    (fr) http://www.java.com/fr/ : Site officiel pour les utilisateurs
    (fr) http://java.developpez.com/ : Communauté de développeurs Java
    (fr) http://news.humancoders.com/t/java - Actualité pour développeurs Java
    (en) http://www.java.net : Site collaboratif officiel avec un wiki
    (en) http://en.wikipedia.org/wiki/Java_version_history Détail de l'historique des versions de Java
    (fr) Catégorie Java de l’annuaire dmoz

Bibliographie

    Ken Arnold, James Gosling et David Holmes, Le Langage Java, 2001 (ISBN 978-2-7117-8671-8)
    (en) Bruce Eckel, Thinking in Java, Prentice-Hall, 2002 (ISBN 978-0-13-100287-6). version téléchargeable version électronique en ligne traduction francophone : penser en java
    Alexandre Brillant, Java 5, 2006 (ISBN 978-2-7460-3170-8)
    Jean Brondeau, Introduction à la programmation objet en Java, Dunod, Paris, 1999 (ISBN 978-2-10-004106-0)
    Annick Fron, Architectures réparties en Java, 2007 (ISBN 978-2-10-051141-9)
